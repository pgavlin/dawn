// Code generated by dawn-gen-builtins; DO NOT EDIT.

package os


import (
	
	util "github.com/pgavlin/dawn/util"
	
	starlark "go.starlark.net/starlark"
	
)



func NewEnviron() *starlark.Builtin {
	const doc = `
   Returns a mapping object where keys and values are strings that represent
   the process environment. This mapping is captured at startup time.
   `
	return starlark.NewBuiltin("environ", Environ).WithDoc(doc)
}


func Environ(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	if err := starlark.UnpackPositionalArgs(fn.Name(), args, kwargs, 0); err != nil {
		return nil, err
	}
	
	return environ(thread, fn)
}


func NewExec() *starlark.Builtin {
	const doc = `
   Run an executable. If the process fails, the calling module will
   abort unless `+"`"+`try_`+"`"+` is set to True, in which case the contents of
   standard error will be returned.

   :param command: a list of strings indicating the executable to run
                   and its arguments (e.g. `+"`"+`["dawn", "build"]`+"`"+`).
   :param cwd: the working directory for the command. Defaults to the
               calling module's directory.
   :param env: any environment variables to set when running the command.
   :param `+"`"+`try_`+"`"+`: when True, the calling module will not be aborted if
                the process fails.

   :returns: the contents of standard error if `+"`"+`try_`+"`"+` is set and None
             otherwise. To capture the process's output, use output.
   `
	return starlark.NewBuiltin("exec", Exec).WithDoc(doc)
}


func Exec(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	var (
		
		cmdV util.StringList
		
		cwd string
		
		envV starlark.IterableMapping
		
		try bool
		
	)
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "command", &cmdV, "cwd??", &cwd, "env??", &envV, "try_??", &try); err != nil {
		return nil, err
	}
	
	return execf(thread, fn, cmdV, cwd, envV, try)
}


func NewOutput() *starlark.Builtin {
	const doc = `
   Run an executable and return its output. If the process fails, the
   calling module will abort unless `+"`"+`try_`+"`"+` is set to True, in which case
   the contents of standard error will be returned.

   :param command: a list of strings indicating the executable to run
                   and its arguments (e.g. `+"`"+`["dawn", "build"]`+"`"+`).
   :param cwd: the working directory for the command. Defaults to the
               calling module's directory.
   :param env: any environment variables to set when running the command.
   :param `+"`"+`try_`+"`"+`: when True, the calling module will not be aborted if
                the process fails.

   :returns: the contents of standard output if `+"`"+`try_`+"`"+` is not truthy and the
             process succeeds. If `+"`"+`try_`+"`"+` is truthy, output returns
             (stdout, True) if the process succeeds and (stderr, False)
             if the process fails.
   `
	return starlark.NewBuiltin("output", Output).WithDoc(doc)
}


func Output(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	var (
		
		cmdV util.StringList
		
		cwd string
		
		envV starlark.IterableMapping
		
		try bool
		
	)
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "command", &cmdV, "cwd??", &cwd, "env??", &envV, "try_??", &try); err != nil {
		return nil, err
	}
	
	return output(thread, fn, cmdV, cwd, envV, try)
}


func NewExists() *starlark.Builtin {
	const doc = `
   Returns true if a file exists at the given path.
   `
	return starlark.NewBuiltin("exists", Exists).WithDoc(doc)
}


func Exists(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	var (
		
		path string
		
	)
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "path", &path); err != nil {
		return nil, err
	}
	
	return exists(thread, fn, path)
}


func NewGetcwd() *starlark.Builtin {
	const doc = `
   Returns the current OS working directory. This is typically the path of
   the directory containg the root module on the callstack.
   `
	return starlark.NewBuiltin("getcwd", Getcwd).WithDoc(doc)
}


func Getcwd(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	if err := starlark.UnpackPositionalArgs(fn.Name(), args, kwargs, 0); err != nil {
		return nil, err
	}
	
	return getcwd(thread, fn)
}


func NewMkdir() *starlark.Builtin {
	const doc = `
   Create a directory named path with numeric mode mode.
   `
	return starlark.NewBuiltin("mkdir", Mkdir).WithDoc(doc)
}


func Mkdir(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	var (
		
		path string
		
		mode int
		
	)
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "path", &path, "mode??", &mode); err != nil {
		return nil, err
	}
	
	return mkdir(thread, fn, path, mode)
}


func NewMakedirs() *starlark.Builtin {
	const doc = `
   Recursive directory creation function. Like mkdir(), but makes all
   intermediate-level directories needed to contain the leaf directory.
   `
	return starlark.NewBuiltin("makedirs", Makedirs).WithDoc(doc)
}


func Makedirs(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	var (
		
		path string
		
		mode int
		
	)
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "path", &path, "mode??", &mode); err != nil {
		return nil, err
	}
	
	return makedirs(thread, fn, path, mode)
}


func NewGlob() *starlark.Builtin {
	const doc = `
   Return a list of paths rooted in the current directory that match the
   given include and exclude patterns.

   - `+"`"+`*`+"`"+` matches any number of non-path-separator characters
   - `+"`"+`**`+"`"+` matches any number of any characters
   - `+"`"+`?`+"`"+` matches a single character

   :param include: the patterns to include.
   :param exclude: the patterns to exclude.

   :returns: the matched paths
   `
	return starlark.NewBuiltin("glob", Glob).WithDoc(doc)
}


func Glob(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	var (
		
		include util.StringList
		
		exclude util.StringList
		
	)
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "include", &include, "exclude??", &exclude); err != nil {
		return nil, err
	}
	
	return glob(thread, fn, include, exclude)
}


