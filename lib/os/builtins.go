// Code generated by dawn-gen-builtins; DO NOT EDIT.

package os

import (
	util "github.com/pgavlin/dawn/util"

	starlark "github.com/pgavlin/starlark-go/starlark"
)

func NewEnviron() *starlark.Builtin {
	const doc = `
    Returns a mapping object where keys and values are strings that represent
    the process environment. This mapping is captured at startup time.
    `
	return starlark.NewBuiltin("environ", Environ).WithDoc(doc)
}

func Environ(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	if err := starlark.UnpackPositionalArgs(fn.Name(), args, kwargs, 0); err != nil {
		return nil, err
	}

	val, err := environ(thread, fn)
	if err != nil {
		return nil, &starlark.EvalError{Msg: err.Error(), CallStack: thread.CallStack()}
	}
	return val, nil
}

func NewLookPath() *starlark.Builtin {
	const doc = `
    Search for an executable named file in the directories named by
    the PATH environment variable. If file contains a slash, it is
    tried directly and the PATH is not consulted. Otherwise, on
    success, the result is an absolute path.

    :param file: the name of the executable to find

    :returns: the absolute path to file if found or None if not found.
    `
	return starlark.NewBuiltin("look_path", LookPath).WithDoc(doc)
}

func LookPath(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	var file string
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "file", &file); err != nil {
		return nil, err
	}

	val, err := lookPath(thread, fn, file)
	if err != nil {
		return nil, &starlark.EvalError{Msg: err.Error(), CallStack: thread.CallStack()}
	}
	return val, nil
}

func NewExec() *starlark.Builtin {
	const doc = `
    Run an executable. If the process fails, the calling module will
    abort unless ` + "`" + `try_` + "`" + ` is set to True, in which case the contents of
    standard error will be returned.

    :param command: a list of strings indicating the executable to run
                    and its arguments (e.g. ` + "`" + `["dawn", "build"]` + "`" + `).
    :param cwd: the working directory for the command. Defaults to the
                calling module's directory.
    :param env: any environment variables to set when running the command.
    :param ` + "`" + `try_` + "`" + `: when True, the calling module will not be aborted if
                 the process fails.

    :returns: the contents of standard error if ` + "`" + `try_` + "`" + ` is set and None
              otherwise. To capture the process's output, use output.
    `
	return starlark.NewBuiltin("exec", Exec).WithDoc(doc)
}

func Exec(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	var (
		cmdV util.StringList

		cwd string

		envV starlark.IterableMapping

		try bool
	)
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "command", &cmdV, "cwd??", &cwd, "env??", &envV, "try_??", &try); err != nil {
		return nil, err
	}

	val, err := execf(thread, fn, cmdV, cwd, envV, try)
	if err != nil {
		return nil, &starlark.EvalError{Msg: err.Error(), CallStack: thread.CallStack()}
	}
	return val, nil
}

func NewOutput() *starlark.Builtin {
	const doc = `
    Run an executable and return its output. If the process fails, the
    calling module will abort unless ` + "`" + `try_` + "`" + ` is set to True, in which case
    the contents of standard error will be returned.

    :param command: a list of strings indicating the executable to run
                    and its arguments (e.g. ` + "`" + `["dawn", "build"]` + "`" + `).
    :param cwd: the working directory for the command. Defaults to the
                calling module's directory.
    :param env: any environment variables to set when running the command.
    :param ` + "`" + `try_` + "`" + `: when True, the calling module will not be aborted if
                 the process fails.

    :returns: the contents of standard output if ` + "`" + `try_` + "`" + ` is not truthy and the
              process succeeds. If ` + "`" + `try_` + "`" + ` is truthy, output returns
              (stdout, True) if the process succeeds and (stderr, False)
              if the process fails.
    `
	return starlark.NewBuiltin("output", Output).WithDoc(doc)
}

func Output(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	var (
		cmdV util.StringList

		cwd string

		envV starlark.IterableMapping

		try bool
	)
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "command", &cmdV, "cwd??", &cwd, "env??", &envV, "try_??", &try); err != nil {
		return nil, err
	}

	val, err := output(thread, fn, cmdV, cwd, envV, try)
	if err != nil {
		return nil, &starlark.EvalError{Msg: err.Error(), CallStack: thread.CallStack()}
	}
	return val, nil
}

func NewExists() *starlark.Builtin {
	const doc = `
    Returns true if a file exists at the given path.
    `
	return starlark.NewBuiltin("exists", Exists).WithDoc(doc)
}

func Exists(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	var path string
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "path", &path); err != nil {
		return nil, err
	}

	val, err := exists(thread, fn, path)
	if err != nil {
		return nil, &starlark.EvalError{Msg: err.Error(), CallStack: thread.CallStack()}
	}
	return val, nil
}

func NewGetcwd() *starlark.Builtin {
	const doc = `
    Returns the current OS working directory. This is typically the path of
    the directory containing the root module on the callstack.
    `
	return starlark.NewBuiltin("getcwd", Getcwd).WithDoc(doc)
}

func Getcwd(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	if err := starlark.UnpackPositionalArgs(fn.Name(), args, kwargs, 0); err != nil {
		return nil, err
	}

	val, err := getcwd(thread, fn)
	if err != nil {
		return nil, &starlark.EvalError{Msg: err.Error(), CallStack: thread.CallStack()}
	}
	return val, nil
}

func NewMkdir() *starlark.Builtin {
	const doc = `
    Create a directory named path with numeric mode mode.
    `
	return starlark.NewBuiltin("mkdir", Mkdir).WithDoc(doc)
}

func Mkdir(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	var (
		path string

		mode int
	)
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "path", &path, "mode??", &mode); err != nil {
		return nil, err
	}

	val, err := mkdir(thread, fn, path, mode)
	if err != nil {
		return nil, &starlark.EvalError{Msg: err.Error(), CallStack: thread.CallStack()}
	}
	return val, nil
}

func NewMakedirs() *starlark.Builtin {
	const doc = `
    Recursive directory creation function. Like mkdir(), but makes all
    intermediate-level directories needed to contain the leaf directory.
    `
	return starlark.NewBuiltin("makedirs", Makedirs).WithDoc(doc)
}

func Makedirs(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	var (
		path string

		mode int
	)
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "path", &path, "mode??", &mode); err != nil {
		return nil, err
	}

	val, err := makedirs(thread, fn, path, mode)
	if err != nil {
		return nil, &starlark.EvalError{Msg: err.Error(), CallStack: thread.CallStack()}
	}
	return val, nil
}
