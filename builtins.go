// Code generated by dawn-gen-builtins; DO NOT EDIT.

package dawn


import (
	
	util "github.com/pgavlin/dawn/util"
	
	starlark "go.starlark.net/starlark"
	
)



func (proj *Project) newBuiltin_path() *starlark.Builtin {
	const doc = `
    Returns the absolute OS path that corresponds to the given label.
    `
	return starlark.NewBuiltin("path", proj.starlark_builtin_path).WithDoc(doc)
}

func (proj *Project) starlark_builtin_path(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	var (
		
		rawlabel string
		
	)
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "label", &rawlabel); err != nil {
		return nil, err
	}
	
	return proj.builtin_path(thread, fn, rawlabel)
}

func (proj *Project) newBuiltin_label() *starlark.Builtin {
	const doc = `
    Returns the label that corresponds to the given OS path, if any.
    `
	return starlark.NewBuiltin("label", proj.starlark_builtin_label).WithDoc(doc)
}

func (proj *Project) starlark_builtin_label(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	var (
		
		path string
		
	)
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "path", &path); err != nil {
		return nil, err
	}
	
	return proj.builtin_label(thread, fn, path)
}

func (proj *Project) newBuiltin_contains() *starlark.Builtin {
	const doc = `
    Returns the label that corresponds to the given OS path if the path i
    contained in the current project. If the path is not contained in the
    current project, contains returns (None, False).
    `
	return starlark.NewBuiltin("contains", proj.starlark_builtin_contains).WithDoc(doc)
}

func (proj *Project) starlark_builtin_contains(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	var (
		
		path string
		
	)
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "path", &path); err != nil {
		return nil, err
	}
	
	return proj.builtin_contains(thread, fn, path)
}

func (proj *Project) newBuiltin_parse_flag() *starlark.Builtin {
	const doc = `
    Defines and parses a new project flag in the current package.

    :param name: the name of the flag.
    :param default: the default value for the flag, if any.
    :param type: the type to which the flag's argument should be converted. Defaults to str.
    :param choices: the valid values for the flag. Defaults to any value.
    :param required: True if the flag must be set.
    :param help: the help string for the flag.

    :returns: the flag's value.
    `
	return starlark.NewBuiltin("parse_flag", proj.starlark_builtin_parse_flag).WithDoc(doc)
}

func (proj *Project) starlark_builtin_parse_flag(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	var (
		
		name string
		
		default_ starlark.Value
		
		type_ starlark.Callable
		
		choices []starlark.Value
		
		required bool
		
		help string
		
	)
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "name", &name, "default??", &default_, "type??", &type_, "choices??", &choices, "required??", &required, "help??", &help); err != nil {
		return nil, err
	}
	
	return proj.builtin_parse_flag(thread, fn, name, default_, type_, choices, required, help)
}

func (proj *Project) newBuiltin_glob() *starlark.Builtin {
	const doc = `
    Return a list of paths relative to the root that match the given include
    and exclude patterns. Typically passed to the sources parameter of target.

    - '*' matches any number of non-path-separator character
    - '**' matches any number of any character
    - '?' matches a single character

    :param include: the patterns to include.
    :param exclude: the patterns to exclude.

    :returns: the matched path
    `
	return starlark.NewBuiltin("glob", proj.starlark_builtin_glob).WithDoc(doc)
}

func (proj *Project) starlark_builtin_glob(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	var (
		
		include util.StringList
		
		exclude util.StringList
		
	)
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "include", &include, "exclude??", &exclude); err != nil {
		return nil, err
	}
	
	return proj.builtin_glob(thread, fn, include, exclude)
}

func (proj *Project) newBuiltin_run() *starlark.Builtin {
	const doc = `
    Builds a target.

    :param label_or_target: the label or target to run.
    :param always: True if all targets should be considered out-of-date.
    :param dry_run: True if the targets to run should be displayed but not run.
    :param callback: a callback that receives build events. If absent,
                     events will be displayed using the default renderer.
    `
	return starlark.NewBuiltin("run", proj.starlark_builtin_run).WithDoc(doc)
}

func (proj *Project) starlark_builtin_run(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	var (
		
		labelOrTarget starlark.Value
		
		always bool
		
		dryRun bool
		
		callback starlark.Callable
		
	)
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "label_or_target", &labelOrTarget, "always??", &always, "dry_run??", &dryRun, "callback??", &callback); err != nil {
		return nil, err
	}
	
	return proj.builtin_run(thread, fn, labelOrTarget, always, dryRun, callback)
}

func (proj *Project) newBuiltin_get_target() *starlark.Builtin {
	const doc = `
    Gets the target with the given label, if it exists.

    :param: label: the target's label.

    :returns: the target with the given label.
    `
	return starlark.NewBuiltin("get_target", proj.starlark_builtin_get_target).WithDoc(doc)
}

func (proj *Project) starlark_builtin_get_target(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	var (
		
		rawlabel string
		
	)
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "label", &rawlabel); err != nil {
		return nil, err
	}
	
	return proj.builtin_get_target(thread, fn, rawlabel)
}

func (proj *Project) newBuiltin_flags() *starlark.Builtin {
	const doc = `
    Lists the project's flags.
    `
	return starlark.NewBuiltin("flags", proj.starlark_builtin_flags).WithDoc(doc)
}

func (proj *Project) starlark_builtin_flags(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	if err := starlark.UnpackPositionalArgs(fn.Name(), args, kwargs, 0); err != nil {
		return nil, err
	}
	
	return proj.builtin_flags(thread, fn)
}

func (proj *Project) newBuiltin_targets() *starlark.Builtin {
	const doc = `
    Lists the project's targets.
    `
	return starlark.NewBuiltin("targets", proj.starlark_builtin_targets).WithDoc(doc)
}

func (proj *Project) starlark_builtin_targets(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	if err := starlark.UnpackPositionalArgs(fn.Name(), args, kwargs, 0); err != nil {
		return nil, err
	}
	
	return proj.builtin_targets(thread, fn)
}

func (proj *Project) newBuiltin_sources() *starlark.Builtin {
	const doc = `
    Lists the project's sources.
    `
	return starlark.NewBuiltin("sources", proj.starlark_builtin_sources).WithDoc(doc)
}

func (proj *Project) starlark_builtin_sources(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	if err := starlark.UnpackPositionalArgs(fn.Name(), args, kwargs, 0); err != nil {
		return nil, err
	}
	
	return proj.builtin_sources(thread, fn)
}

