// Code generated by dawn-gen-builtins; DO NOT EDIT.

package dawn


import (
	
	util "github.com/pgavlin/dawn/util"
	
	starlark "go.starlark.net/starlark"
	
)



func (c *cache) newOnce() *starlark.Builtin {
	const doc = `
   once calls the given callable if and only if key is not present in the cache.

   The result is stored in the cache under the given key.

   Returns the result of the call or the cached value.
   `
	return starlark.NewBuiltin("once", c.starlark_once).WithDoc(doc)
}


func (c *cache) starlark_once(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	var (
		
		key string
		
		function starlark.Callable
		
	)
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "key", &key, "callable", &function); err != nil {
		return nil, err
	}
	
	val, err := c.once(thread, fn, key, function)
	if err != nil {
		return nil, &starlark.EvalError{Msg: err.Error(), CallStack: thread.CallStack()}
	}
	return val, nil
}


func (proj *Project) newBuiltin_path() *starlark.Builtin {
	const doc = `
   Returns the absolute OS path that corresponds to the given label.
   `
	return starlark.NewBuiltin("path", proj.starlark_builtin_path).WithDoc(doc)
}


func (proj *Project) starlark_builtin_path(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	var (
		
		rawlabel string
		
	)
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "label", &rawlabel); err != nil {
		return nil, err
	}
	
	val, err := proj.builtin_path(thread, fn, rawlabel)
	if err != nil {
		return nil, &starlark.EvalError{Msg: err.Error(), CallStack: thread.CallStack()}
	}
	return val, nil
}


func (proj *Project) newBuiltin_label() *starlark.Builtin {
	const doc = `
   Returns the label that corresponds to the given OS path, if any.
   `
	return starlark.NewBuiltin("label", proj.starlark_builtin_label).WithDoc(doc)
}


func (proj *Project) starlark_builtin_label(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	var (
		
		path string
		
	)
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "path", &path); err != nil {
		return nil, err
	}
	
	val, err := proj.builtin_label(thread, fn, path)
	if err != nil {
		return nil, &starlark.EvalError{Msg: err.Error(), CallStack: thread.CallStack()}
	}
	return val, nil
}


func (proj *Project) newBuiltin_contains() *starlark.Builtin {
	const doc = `
   Returns the label that corresponds to the given OS path if the path is
   contained in the current project. If the path is not contained in the
   current project, contains returns (None, False).
   `
	return starlark.NewBuiltin("contains", proj.starlark_builtin_contains).WithDoc(doc)
}


func (proj *Project) starlark_builtin_contains(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	var (
		
		path string
		
	)
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "path", &path); err != nil {
		return nil, err
	}
	
	val, err := proj.builtin_contains(thread, fn, path)
	if err != nil {
		return nil, &starlark.EvalError{Msg: err.Error(), CallStack: thread.CallStack()}
	}
	return val, nil
}


func (proj *Project) newBuiltin_parse_flag() *starlark.Builtin {
	const doc = `
   Defines and parses a new project flag in the current package.

   :param name: the name of the flag.
   :param default: the default value for the flag, if any.
   :param type: the type to which the flag's argument should be converted. Defaults to str.
   :param choices: the valid values for the flag. Defaults to any value.
   :param required: True if the flag must be set.
   :param help: the help string for the flag.

   :returns: the flag's value.
   `
	return starlark.NewBuiltin("parse_flag", proj.starlark_builtin_parse_flag).WithDoc(doc)
}


func (proj *Project) starlark_builtin_parse_flag(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	var (
		
		name string
		
		default_ starlark.Value
		
		type_ starlark.Callable
		
		choices []starlark.Value
		
		required bool
		
		help string
		
	)
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "name", &name, "default??", &default_, "type??", &type_, "choices??", &choices, "required??", &required, "help??", &help); err != nil {
		return nil, err
	}
	
	val, err := proj.builtin_parse_flag(thread, fn, name, default_, type_, choices, required, help)
	if err != nil {
		return nil, &starlark.EvalError{Msg: err.Error(), CallStack: thread.CallStack()}
	}
	return val, nil
}


func (proj *Project) newBuiltin_target() *starlark.Builtin {
	const doc = `
   Defines a new build target in the current package. Typically used as a
   decorator, in which case the decorated function is treated as the value
   of the function parameter.

   :param name: the name of the target.
   :param deps: the target's dependencies. Must be a sequence whose elements
                are either labels or other build targets.
   :param sources: the target's source files. Must be a sequence of strings.
                   Each string will be interpreted relative to the package's
                   directory (if the path is relative) or project root (if
                   the path is absolute).
   :param generates: any files generated by the targets. Must be a sequence of
                     strings. Paths are interpreted identically to those in
                     the sources parameter.
   :param function: the target's callback function. If this parameter is None,
                    target returns a decorator function rather than a target.
   :param default: True if the target is its package's default target.
   :param always: True if the target should always be considered out-of-date.
   :param docs: the docs for the target. Normally picked up from the
                function's docstring.

   :returns: the new build target object or a decorator if function is None.
   `
	return starlark.NewBuiltin("target", proj.starlark_builtin_target).WithDoc(doc)
}


func (proj *Project) starlark_builtin_target(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	var (
		
		name string
		
		deps starlark.Sequence
		
		sources util.StringList
		
		generates util.StringList
		
		function *starlark.Function
		
		default_ bool
		
		always bool
		
		docs string
		
	)
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "name??", &name, "deps??", &deps, "sources??", &sources, "generates??", &generates, "function??", &function, "default??", &default_, "always??", &always, "docs??", &docs); err != nil {
		return nil, err
	}
	
	val, err := proj.builtin_target(thread, fn, name, deps, sources, generates, function, default_, always, docs)
	if err != nil {
		return nil, &starlark.EvalError{Msg: err.Error(), CallStack: thread.CallStack()}
	}
	return val, nil
}


func (proj *Project) newBuiltin_glob() *starlark.Builtin {
	const doc = `
   Return a list of paths relative to the calling module's directory that match
   the given include and exclude patterns. Typically passed to the sources parameter
   of target.

   - `+"`"+`*`+"`"+` matches any number of non-path-separator characters
   - `+"`"+`**`+"`"+` matches any number of any characters
   - `+"`"+`?`+"`"+` matches a single character

   :param include: the patterns to include.
   :param exclude: the patterns to exclude.

   :returns: the matched paths
   `
	return starlark.NewBuiltin("glob", proj.starlark_builtin_glob).WithDoc(doc)
}


func (proj *Project) starlark_builtin_glob(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	var (
		
		include util.StringList
		
		exclude util.StringList
		
	)
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "include", &include, "exclude??", &exclude); err != nil {
		return nil, err
	}
	
	val, err := proj.builtin_glob(thread, fn, include, exclude)
	if err != nil {
		return nil, &starlark.EvalError{Msg: err.Error(), CallStack: thread.CallStack()}
	}
	return val, nil
}


func (proj *Project) newBuiltin_run() *starlark.Builtin {
	const doc = `
   Builds a target.

   :param label_or_target: the label or target to run.
   :param always: True if all targets should be considered out-of-date.
   :param dry_run: True if the targets to run should be displayed but not run.
   :param callback: a callback that receives build events. If absent,
                    events will be displayed using the default renderer.
   `
	return starlark.NewBuiltin("run", proj.starlark_builtin_run).WithDoc(doc)
}


func (proj *Project) starlark_builtin_run(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	var (
		
		labelOrTarget starlark.Value
		
		always bool
		
		dryRun bool
		
		callback starlark.Callable
		
	)
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "label_or_target", &labelOrTarget, "always??", &always, "dry_run??", &dryRun, "callback??", &callback); err != nil {
		return nil, err
	}
	
	val, err := proj.builtin_run(thread, fn, labelOrTarget, always, dryRun, callback)
	if err != nil {
		return nil, &starlark.EvalError{Msg: err.Error(), CallStack: thread.CallStack()}
	}
	return val, nil
}


func (proj *Project) newBuiltin_get_target() *starlark.Builtin {
	const doc = `
   Gets the target with the given label, if it exists.

   :param: label: the target's label.

   :returns: the target with the given label.
   `
	return starlark.NewBuiltin("get_target", proj.starlark_builtin_get_target).WithDoc(doc)
}


func (proj *Project) starlark_builtin_get_target(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	var (
		
		rawlabel string
		
	)
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "label", &rawlabel); err != nil {
		return nil, err
	}
	
	val, err := proj.builtin_get_target(thread, fn, rawlabel)
	if err != nil {
		return nil, &starlark.EvalError{Msg: err.Error(), CallStack: thread.CallStack()}
	}
	return val, nil
}


func (proj *Project) newBuiltin_flags() *starlark.Builtin {
	const doc = `
   Lists the project's flags.
   `
	return starlark.NewBuiltin("flags", proj.starlark_builtin_flags).WithDoc(doc)
}


func (proj *Project) starlark_builtin_flags(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	if err := starlark.UnpackPositionalArgs(fn.Name(), args, kwargs, 0); err != nil {
		return nil, err
	}
	
	val, err := proj.builtin_flags(thread, fn)
	if err != nil {
		return nil, &starlark.EvalError{Msg: err.Error(), CallStack: thread.CallStack()}
	}
	return val, nil
}


func (proj *Project) newBuiltin_targets() *starlark.Builtin {
	const doc = `
   Lists the project's targets.
   `
	return starlark.NewBuiltin("targets", proj.starlark_builtin_targets).WithDoc(doc)
}


func (proj *Project) starlark_builtin_targets(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	if err := starlark.UnpackPositionalArgs(fn.Name(), args, kwargs, 0); err != nil {
		return nil, err
	}
	
	val, err := proj.builtin_targets(thread, fn)
	if err != nil {
		return nil, &starlark.EvalError{Msg: err.Error(), CallStack: thread.CallStack()}
	}
	return val, nil
}


func (proj *Project) newBuiltin_sources() *starlark.Builtin {
	const doc = `
   Lists the project's sources.
   `
	return starlark.NewBuiltin("sources", proj.starlark_builtin_sources).WithDoc(doc)
}


func (proj *Project) starlark_builtin_sources(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	if err := starlark.UnpackPositionalArgs(fn.Name(), args, kwargs, 0); err != nil {
		return nil, err
	}
	
	val, err := proj.builtin_sources(thread, fn)
	if err != nil {
		return nil, &starlark.EvalError{Msg: err.Error(), CallStack: thread.CallStack()}
	}
	return val, nil
}


func (proj *Project) newBuiltin_fail() *starlark.Builtin {
	const doc = `
   Fails the calling target with the given message.
   `
	return starlark.NewBuiltin("fail", proj.starlark_builtin_fail).WithDoc(doc)
}


func (proj *Project) starlark_builtin_fail(thread *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	
	var (
		
		message string
		
	)
	if err := starlark.UnpackArgs(fn.Name(), args, kwargs, "message", &message); err != nil {
		return nil, err
	}
	
	val, err := proj.builtin_fail(thread, fn, message)
	if err != nil {
		return nil, &starlark.EvalError{Msg: err.Error(), CallStack: thread.CallStack()}
	}
	return val, nil
}


